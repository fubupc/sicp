(define (sum? e)
  (and (pair? e)
       (eq? (car e) '+)))

(define (make-sum . s)
  (define (sum-iter num-sum symbols seq)
    (if (null? seq)
      (cond ((null? symbols) num-sum)
            ((= num-sum 0) 
             (if (= 1 (length symbols))
               (car symbols)
               (cons '+ symbols)))
            (else (cons '+ (cons num-sum symbols))))
      (let ((next (car seq))
            (rest (cdr seq)))
        (cond ((number? next) (sum-iter (+ num-sum next) symbols rest))
              ((and (pair? next) (sum? next)) (sum-iter num-sum symbols (append (cdr next) rest)))
              (else (sum-iter num-sum (append symbols (list next)) rest))))))
  (sum-iter 0 '() s))

(define (addend e)
  (cadr e))

(define (augend e)
  (let ((_aug (cddr e)))
    (if (= (length _aug) 1)
      (car _aug)
      (cons '+ _aug))))

(define (make-product . s)
  (define (mul-iter num-product symbols seq)
    (if (null? seq)
      (cond ((null? symbols) num-product)
            ((= num-product 1)
             (if (= 1 (length symbols))
               (car symbols)
               (cons '* symbols)))
            (else (cons '* (cons num-product symbols))))
      (let ((next (car seq))
            (rest (cdr seq)))
        (cond ((and (number? next) (= next 0)) 0)  ; return early.
              ((number? next) (mul-iter (* num-product next) symbols rest))
              ((product? next) (mul-iter num-product symbols (append (cdr next) rest)))
              (else (mul-iter num-product (append symbols (list next)) rest))))))
  (mul-iter 1 '() s))

(define (multiplier e)
  (cadr e))

(define (multiplicand e)
  (let ((_mul (cddr e)))
    (if (= (length _mul) 1)
      (car _mul)
      (cons '* _mul))))

